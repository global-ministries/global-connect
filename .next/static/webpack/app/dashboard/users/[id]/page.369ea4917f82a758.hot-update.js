"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/users/[id]/page",{

/***/ "(app-pages-browser)/./hooks/use-usuario-detalle.ts":
/*!**************************************!*\
  !*** ./hooks/use-usuario-detalle.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useUsuarioDetalle: () => (/* binding */ useUsuarioDetalle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _lib_config_relaciones_familiares__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/config/relaciones-familiares */ \"(app-pages-browser)/./lib/config/relaciones-familiares.ts\");\n\n\n\nfunction useUsuarioDetalle(id) {\n    const [usuario, setUsuario] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(\"https://wcnqocyqtksxhthnquta.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjbnFvY3lxdGtzeGh0aG5xdXRhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY4Mzk0NjIsImV4cCI6MjA2MjQxNTQ2Mn0.pDQP3Yx1XU1Wh3AYGSKB8qlrPz8_5_wI4IhfjjLvtZg\");\n    const cargarUsuario = async ()=>{\n        try {\n            setLoading(true);\n            setError(null);\n            console.log('üîç Cargando usuario con ID:', id);\n            // Primero, obtener el usuario b√°sico\n            const { data: usuarioBasico, error: errorUsuario } = await supabase.from('usuarios').select('*').eq('id', id).single();\n            if (errorUsuario) {\n                console.error('‚ùå Error al obtener usuario b√°sico:', errorUsuario);\n                setError(\"Error al cargar usuario: \".concat(errorUsuario.message));\n                return;\n            }\n            console.log('‚úÖ Usuario b√°sico obtenido:', usuarioBasico);\n            // Luego, obtener los roles del usuario\n            const { data: usuarioRoles, error: errorRoles } = await supabase.from('usuario_roles').select('rol_id, usuario_id').eq('usuario_id', id);\n            if (errorRoles) {\n                console.error('‚ùå Error al obtener roles:', errorRoles);\n            // No fallamos aqu√≠, solo log del error\n            }\n            console.log('‚úÖ Roles obtenidos:', usuarioRoles);\n            // Obtener informaci√≥n de los roles del sistema\n            let rolesCompletos = [];\n            if (usuarioRoles && usuarioRoles.length > 0) {\n                const rolIds = usuarioRoles.map((ur)=>ur.rol_id);\n                const { data: rolesSistema, error: errorRolesSistema } = await supabase.from('roles_sistema').select('id, nombre_interno, nombre_visible').in('id', rolIds);\n                if (!errorRolesSistema && rolesSistema) {\n                    rolesCompletos = usuarioRoles.map((ur)=>({\n                            rol_id: ur.rol_id,\n                            usuario_id: ur.usuario_id,\n                            roles_sistema: rolesSistema.find((rs)=>rs.id === ur.rol_id)\n                        }));\n                    console.log('‚úÖ Roles del sistema obtenidos:', rolesCompletos);\n                }\n            }\n            // Obtener direcci√≥n si existe\n            let direccion = undefined;\n            if (usuarioBasico.direccion_id) {\n                const { data: dirData, error: errorDir } = await supabase.from('direcciones').select('*').eq('id', usuarioBasico.direccion_id).single();\n                if (!errorDir) {\n                    direccion = dirData;\n                    console.log('‚úÖ Direcci√≥n obtenida:', direccion);\n                }\n            }\n            // Obtener familia si existe\n            let familia = undefined;\n            if (usuarioBasico.familia_id) {\n                const { data: famData, error: errorFam } = await supabase.from('familias').select('*').eq('id', usuarioBasico.familia_id).single();\n                if (!errorFam) {\n                    familia = famData;\n                    console.log('‚úÖ Familia obtenida:', familia);\n                }\n            }\n            // Obtener ocupaci√≥n si existe\n            let ocupacion = undefined;\n            if (usuarioBasico.ocupacion_id) {\n                const { data: ocData, error: errorOc } = await supabase.from('ocupaciones').select('*').eq('id', usuarioBasico.ocupacion_id).single();\n                if (!errorOc) {\n                    ocupacion = ocData;\n                    console.log('‚úÖ Ocupaci√≥n obtenida:', ocupacion);\n                }\n            }\n            // Obtener profesi√≥n si existe\n            let profesion = undefined;\n            if (usuarioBasico.profesion_id) {\n                const { data: profData, error: errorProf } = await supabase.from('profesiones').select('*').eq('id', usuarioBasico.profesion_id).single();\n                if (!errorProf) {\n                    profesion = profData;\n                    console.log('‚úÖ Profesi√≥n obtenida:', profesion);\n                }\n            }\n            // Obtener relaciones familiares si existen\n            let relacionesFamiliares = undefined;\n            console.log('üîç Buscando relaciones familiares para usuario:', id);\n            // Buscar relaciones donde este usuario es usuario1 o usuario2\n            const { data: relaciones, error: errorRelaciones } = await supabase.from('relaciones_usuarios').select('id, tipo_relacion, es_principal, usuario1_id, usuario2_id').or(\"usuario1_id.eq.\".concat(id, \",usuario2_id.eq.\").concat(id));\n            console.log('üîç Consulta de relaciones:', {\n                relaciones,\n                errorRelaciones\n            });\n            if (!errorRelaciones && relaciones && relaciones.length > 0) {\n                console.log('‚úÖ Relaciones encontradas:', relaciones);\n                // Obtener los IDs de los usuarios relacionados\n                const idsRelacionados = relaciones.map((r)=>{\n                    const esUsuario1 = r.usuario1_id === id;\n                    const familiarId = esUsuario1 ? r.usuario2_id : r.usuario1_id;\n                    console.log(\"\\uD83D\\uDD0D Relaci\\xf3n: usuario1=\".concat(r.usuario1_id, \", usuario2=\").concat(r.usuario2_id, \", tipo=\").concat(r.tipo_relacion));\n                    console.log(\"\\uD83D\\uDD0D Usuario actual: \".concat(id, \", Familiar ID: \").concat(familiarId));\n                    return familiarId;\n                });\n                console.log('üîç IDs de usuarios relacionados:', idsRelacionados);\n                // Obtener informaci√≥n de los usuarios relacionados\n                const { data: usuariosFamiliares, error: errorUsuariosFamiliares } = await supabase.from('usuarios').select('*').in('id', idsRelacionados);\n                console.log('üîç Usuarios familiares obtenidos:', {\n                    usuariosFamiliares,\n                    errorUsuariosFamiliares\n                });\n                if (!errorUsuariosFamiliares && usuariosFamiliares) {\n                    relacionesFamiliares = relaciones.map((r)=>{\n                        const esUsuario1 = r.usuario1_id === id;\n                        const familiarId = esUsuario1 ? r.usuario2_id : r.usuario1_id;\n                        const familiar = usuariosFamiliares.find((uf)=>uf.id === familiarId);\n                        console.log(\"\\uD83D\\uDD0D Construyendo relaci\\xf3n:\", {\n                            relacionId: r.id,\n                            tipo: r.tipo_relacion,\n                            esPrincipal: r.es_principal,\n                            familiarId,\n                            familiarEncontrado: !!familiar,\n                            familiarNombre: familiar ? \"\".concat(familiar.nombre, \" \").concat(familiar.apellido) : 'NO ENCONTRADO',\n                            esUsuario1,\n                            usuarioActual: id,\n                            usuario1: r.usuario1_id,\n                            usuario2: r.usuario2_id\n                        });\n                        // Invertir la relaci√≥n si el usuario actual es usuario1_id\n                        let tipoRelacionMostrado = r.tipo_relacion;\n                        if (esUsuario1) {\n                            // Solo invertir si la relaci√≥n no es rec√≠proca\n                            if (!(0,_lib_config_relaciones_familiares__WEBPACK_IMPORTED_MODULE_1__.esRelacionReciproca)(r.tipo_relacion)) {\n                                const relacionInvertida = (0,_lib_config_relaciones_familiares__WEBPACK_IMPORTED_MODULE_1__.invertirRelacion)(r.tipo_relacion);\n                                if (relacionInvertida) {\n                                    tipoRelacionMostrado = relacionInvertida;\n                                }\n                            }\n                        }\n                        return {\n                            id: r.id,\n                            tipo_relacion: tipoRelacionMostrado,\n                            es_principal: r.es_principal,\n                            familiar: familiar,\n                            es_usuario1: esUsuario1,\n                            tipo_relacion_original: r.tipo_relacion // Para debug\n                        };\n                    }).filter((r)=>r.familiar) // Solo incluir relaciones con usuarios v√°lidos\n                    ;\n                    console.log('‚úÖ Relaciones familiares construidas:', relacionesFamiliares);\n                }\n            } else {\n                console.log('‚ÑπÔ∏è No se encontraron relaciones familiares o hubo error:', errorRelaciones);\n            }\n            // Construir el objeto completo del usuario\n            const usuarioCompleto = {\n                ...usuarioBasico,\n                usuario_roles: rolesCompletos,\n                direccion,\n                familia,\n                ocupacion,\n                profesion,\n                relaciones_familiares: relacionesFamiliares\n            };\n            console.log('‚úÖ Usuario completo construido:', usuarioCompleto);\n            setUsuario(usuarioCompleto);\n        } catch (err) {\n            console.error('‚ùå Error inesperado:', err);\n            setError('Error inesperado al cargar datos');\n        } finally{\n            setLoading(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useUsuarioDetalle.useEffect\": ()=>{\n            if (id) {\n                cargarUsuario();\n            }\n        }\n    }[\"useUsuarioDetalle.useEffect\"], [\n        id\n    ]);\n    return {\n        usuario,\n        loading,\n        error,\n        recargar: cargarUsuario\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS11c3VhcmlvLWRldGFsbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFDUztBQUVzQztBQStCbkYsU0FBU0ssa0JBQWtCQyxFQUFVO0lBQzFDLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHUiwrQ0FBUUEsQ0FBMEI7SUFDaEUsTUFBTSxDQUFDUyxTQUFTQyxXQUFXLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsTUFBTWEsV0FBV1gsbUVBQVlBLENBQzNCWSwwQ0FBb0MsRUFDcENBLGtOQUF5QztJQUczQyxNQUFNSSxnQkFBZ0I7UUFDcEIsSUFBSTtZQUNGUixXQUFXO1lBQ1hFLFNBQVM7WUFFVE8sUUFBUUMsR0FBRyxDQUFDLCtCQUErQmQ7WUFFM0MscUNBQXFDO1lBQ3JDLE1BQU0sRUFBRWUsTUFBTUMsYUFBYSxFQUFFWCxPQUFPWSxZQUFZLEVBQUUsR0FBRyxNQUFNVixTQUN4RFcsSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxFQUFFLENBQUMsTUFBTXBCLElBQ1RxQixNQUFNO1lBRVQsSUFBSUosY0FBYztnQkFDaEJKLFFBQVFSLEtBQUssQ0FBQyxzQ0FBc0NZO2dCQUNwRFgsU0FBUyw0QkFBaUQsT0FBckJXLGFBQWFLLE9BQU87Z0JBQ3pEO1lBQ0Y7WUFFQVQsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QkU7WUFFMUMsdUNBQXVDO1lBQ3ZDLE1BQU0sRUFBRUQsTUFBTVEsWUFBWSxFQUFFbEIsT0FBT21CLFVBQVUsRUFBRSxHQUFHLE1BQU1qQixTQUNyRFcsSUFBSSxDQUFDLGlCQUNMQyxNQUFNLENBQUMsc0JBQ1BDLEVBQUUsQ0FBQyxjQUFjcEI7WUFFcEIsSUFBSXdCLFlBQVk7Z0JBQ2RYLFFBQVFSLEtBQUssQ0FBQyw2QkFBNkJtQjtZQUMzQyx1Q0FBdUM7WUFDekM7WUFFQVgsUUFBUUMsR0FB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Qzs7b0JBRTFFdkQsUUFBUUMsR0FBRyxDQUFDLHdDQUF3Q3lDO2dCQUN0RDtZQUNGLE9BQU87Z0JBQ0wxQyxRQUFRQyxHQUFHLENBQUMsNERBQTREMkM7WUFDMUU7WUFFQSwyQ0FBMkM7WUFDM0MsTUFBTTZCLGtCQUFvQztnQkFDeEMsR0FBR3RFLGFBQWE7Z0JBQ2hCdUUsZUFBZTlEO2dCQUNmYTtnQkFDQUs7Z0JBQ0FJO2dCQUNBSTtnQkFDQXFDLHVCQUF1QmpDO1lBQ3pCO1lBRUExQyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDd0U7WUFDOUNwRixXQUFXb0Y7UUFFYixFQUFFLE9BQU9HLEtBQUs7WUFDWjVFLFFBQVFSLEtBQUssQ0FBQyx1QkFBdUJvRjtZQUNyQ25GLFNBQVM7UUFDWCxTQUFVO1lBQ1JGLFdBQVc7UUFDYjtJQUNGO0lBRUFULGdEQUFTQTt1Q0FBQztZQUNSLElBQUlLLElBQUk7Z0JBQ05ZO1lBQ0Y7UUFDRjtzQ0FBRztRQUFDWjtLQUFHO0lBRVAsT0FBTztRQUNMQztRQUNBRTtRQUNBRTtRQUNBcUYsVUFBVTlFO0lBQ1o7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2lzYWFjcGFlenovR2xvYmFsIENvbm5lY3QvaG9va3MvdXNlLXVzdWFyaW8tZGV0YWxsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5pbXBvcnQgdHlwZSB7IERhdGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvZGF0YWJhc2UudHlwZXMnXG5pbXBvcnQgeyBpbnZlcnRpclJlbGFjaW9uLCBlc1JlbGFjaW9uUmVjaXByb2NhIH0gZnJvbSAnQC9saWIvY29uZmlnL3JlbGFjaW9uZXMtZmFtaWxpYXJlcydcblxudHlwZSBVc3VhcmlvID0gRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJUYWJsZXNcIl1bXCJ1c3Vhcmlvc1wiXVtcIlJvd1wiXVxudHlwZSBVc3VhcmlvUm9sID0gRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJUYWJsZXNcIl1bXCJ1c3VhcmlvX3JvbGVzXCJdW1wiUm93XCJdXG50eXBlIFJvbFNpc3RlbWEgPSBEYXRhYmFzZVtcInB1YmxpY1wiXVtcIlRhYmxlc1wiXVtcInJvbGVzX3Npc3RlbWFcIl1bXCJSb3dcIl1cbnR5cGUgRGlyZWNjaW9uID0gRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJUYWJsZXNcIl1bXCJkaXJlY2Npb25lc1wiXVtcIlJvd1wiXVxudHlwZSBGYW1pbGlhID0gRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJUYWJsZXNcIl1bXCJmYW1pbGlhc1wiXVtcIlJvd1wiXVxudHlwZSBPY3VwYWNpb24gPSBEYXRhYmFzZVtcInB1YmxpY1wiXVtcIlRhYmxlc1wiXVtcIm9jdXBhY2lvbmVzXCJdW1wiUm93XCJdXG50eXBlIFByb2Zlc2lvbiA9IERhdGFiYXNlW1wicHVibGljXCJdW1wiVGFibGVzXCJdW1wicHJvZmVzaW9uZXNcIl1bXCJSb3dcIl1cbnR5cGUgUmVsYWNpb25Vc3VhcmlvID0gRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJUYWJsZXNcIl1bXCJyZWxhY2lvbmVzX3VzdWFyaW9zXCJdW1wiUm93XCJdXG5cbmV4cG9ydCB0eXBlIFVzdWFyaW9EZXRhbGxhZG8gPSBVc3VhcmlvICYge1xuICB1c3VhcmlvX3JvbGVzPzoge1xuICAgIHJvbF9pZDogc3RyaW5nXG4gICAgdXN1YXJpb19pZDogc3RyaW5nXG4gICAgcm9sZXNfc2lzdGVtYT86IFJvbFNpc3RlbWFcbiAgfVtdXG4gIGRpcmVjY2lvbj86IERpcmVjY2lvblxuICBmYW1pbGlhPzogRmFtaWxpYVxuICBvY3VwYWNpb24/OiBPY3VwYWNpb25cbiAgcHJvZmVzaW9uPzogUHJvZmVzaW9uXG4gIHJlbGFjaW9uZXNfZmFtaWxpYXJlcz86IHtcbiAgICBpZDogc3RyaW5nXG4gICAgdGlwb19yZWxhY2lvbjogRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJFbnVtc1wiXVtcImVudW1fdGlwb19yZWxhY2lvblwiXVxuICAgIGVzX3ByaW5jaXBhbDogYm9vbGVhbiB8IG51bGxcbiAgICBmYW1pbGlhcjogVXN1YXJpb1xuICAgIGVzX3VzdWFyaW8xOiBib29sZWFuIC8vIFBhcmEgZGVidWc6IGluZGljYSBzaSBlbCB1c3VhcmlvIGFjdHVhbCBlcyB1c3VhcmlvMSBlbiBlc3RhIHJlbGFjacOzblxuICAgIHRpcG9fcmVsYWNpb25fb3JpZ2luYWw6IERhdGFiYXNlW1wicHVibGljXCJdW1wiRW51bXNcIl1bXCJlbnVtX3RpcG9fcmVsYWNpb25cIl0gLy8gUGFyYSBkZWJ1ZzogdGlwbyBvcmlnaW5hbCBkZSBsYSBCRFxuICB9W11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVzdWFyaW9EZXRhbGxlKGlkOiBzdHJpbmcpIHtcbiAgY29uc3QgW3VzdWFyaW8sIHNldFVzdWFyaW9dID0gdXNlU3RhdGU8VXN1YXJpb0RldGFsbGFkbyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcblxuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudDxEYXRhYmFzZT4oXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcbiAgKVxuXG4gIGNvbnN0IGNhcmdhclVzdWFyaW8gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgIHNldEVycm9yKG51bGwpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIENhcmdhbmRvIHVzdWFyaW8gY29uIElEOicsIGlkKVxuICAgICAgXG4gICAgICAvLyBQcmltZXJvLCBvYnRlbmVyIGVsIHVzdWFyaW8gYsOhc2ljb1xuICAgICAgY29uc3QgeyBkYXRhOiB1c3VhcmlvQmFzaWNvLCBlcnJvcjogZXJyb3JVc3VhcmlvIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXN1YXJpb3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yVXN1YXJpbykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWwgb2J0ZW5lciB1c3VhcmlvIGLDoXNpY286JywgZXJyb3JVc3VhcmlvKVxuICAgICAgICBzZXRFcnJvcihgRXJyb3IgYWwgY2FyZ2FyIHVzdWFyaW86ICR7ZXJyb3JVc3VhcmlvLm1lc3NhZ2V9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVXN1YXJpbyBiw6FzaWNvIG9idGVuaWRvOicsIHVzdWFyaW9CYXNpY28pXG5cbiAgICAgIC8vIEx1ZWdvLCBvYnRlbmVyIGxvcyByb2xlcyBkZWwgdXN1YXJpb1xuICAgICAgY29uc3QgeyBkYXRhOiB1c3VhcmlvUm9sZXMsIGVycm9yOiBlcnJvclJvbGVzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXN1YXJpb19yb2xlcycpXG4gICAgICAgIC5zZWxlY3QoJ3JvbF9pZCwgdXN1YXJpb19pZCcpXG4gICAgICAgIC5lcSgndXN1YXJpb19pZCcsIGlkKVxuXG4gICAgICBpZiAoZXJyb3JSb2xlcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWwgb2J0ZW5lciByb2xlczonLCBlcnJvclJvbGVzKVxuICAgICAgICAvLyBObyBmYWxsYW1vcyBhcXXDrSwgc29sbyBsb2cgZGVsIGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUm9sZXMgb2J0ZW5pZG9zOicsIHVzdWFyaW9Sb2xlcylcblxuICAgICAgLy8gT2J0ZW5lciBpbmZvcm1hY2nDs24gZGUgbG9zIHJvbGVzIGRlbCBzaXN0ZW1hXG4gICAgICBsZXQgcm9sZXNDb21wbGV0b3M6IHsgcm9sX2lkOiBzdHJpbmc7IHVzdWFyaW9faWQ6IHN0cmluZzsgcm9sZXNfc2lzdGVtYT86IFJvbFNpc3RlbWEgfVtdID0gW11cbiAgICAgIGlmICh1c3VhcmlvUm9sZXMgJiYgdXN1YXJpb1JvbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgcm9sSWRzID0gdXN1YXJpb1JvbGVzLm1hcCh1ciA9PiB1ci5yb2xfaWQpXG4gICAgICAgIGNvbnN0IHsgZGF0YTogcm9sZXNTaXN0ZW1hLCBlcnJvcjogZXJyb3JSb2xlc1Npc3RlbWEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3JvbGVzX3Npc3RlbWEnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkLCBub21icmVfaW50ZXJubywgbm9tYnJlX3Zpc2libGUnKVxuICAgICAgICAgIC5pbignaWQnLCByb2xJZHMpXG5cbiAgICAgICAgaWYgKCFlcnJvclJvbGVzU2lzdGVtYSAmJiByb2xlc1Npc3RlbWEpIHtcbiAgICAgICAgICByb2xlc0NvbXBsZXRvcyA9IHVzdWFyaW9Sb2xlcy5tYXAodXIgPT4gKHtcbiAgICAgICAgICAgIHJvbF9pZDogdXIucm9sX2lkLFxuICAgICAgICAgICAgdXN1YXJpb19pZDogdXIudXN1YXJpb19pZCxcbiAgICAgICAgICAgIHJvbGVzX3Npc3RlbWE6IHJvbGVzU2lzdGVtYS5maW5kKHJzID0+IHJzLmlkID09PSB1ci5yb2xfaWQpXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBSb2xlcyBkZWwgc2lzdGVtYSBvYnRlbmlkb3M6Jywgcm9sZXNDb21wbGV0b3MpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZW5lciBkaXJlY2Npw7NuIHNpIGV4aXN0ZVxuICAgICAgbGV0IGRpcmVjY2lvbjogRGlyZWNjaW9uIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICAgICBpZiAodXN1YXJpb0Jhc2ljby5kaXJlY2Npb25faWQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBkaXJEYXRhLCBlcnJvcjogZXJyb3JEaXIgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2RpcmVjY2lvbmVzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAuZXEoJ2lkJywgdXN1YXJpb0Jhc2ljby5kaXJlY2Npb25faWQpXG4gICAgICAgICAgLnNpbmdsZSgpXG4gICAgICAgIFxuICAgICAgICBpZiAoIWVycm9yRGlyKSB7XG4gICAgICAgICAgZGlyZWNjaW9uID0gZGlyRGF0YVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRGlyZWNjacOzbiBvYnRlbmlkYTonLCBkaXJlY2Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZW5lciBmYW1pbGlhIHNpIGV4aXN0ZVxuICAgICAgbGV0IGZhbWlsaWE6IEZhbWlsaWEgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGlmICh1c3VhcmlvQmFzaWNvLmZhbWlsaWFfaWQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBmYW1EYXRhLCBlcnJvcjogZXJyb3JGYW0gfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2ZhbWlsaWFzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAuZXEoJ2lkJywgdXN1YXJpb0Jhc2ljby5mYW1pbGlhX2lkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFlcnJvckZhbSkge1xuICAgICAgICAgIGZhbWlsaWEgPSBmYW1EYXRhXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBGYW1pbGlhIG9idGVuaWRhOicsIGZhbWlsaWEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZW5lciBvY3VwYWNpw7NuIHNpIGV4aXN0ZVxuICAgICAgbGV0IG9jdXBhY2lvbjogT2N1cGFjaW9uIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gICAgICBpZiAodXN1YXJpb0Jhc2ljby5vY3VwYWNpb25faWQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBvY0RhdGEsIGVycm9yOiBlcnJvck9jIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdvY3VwYWNpb25lcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmVxKCdpZCcsIHVzdWFyaW9CYXNpY28ub2N1cGFjaW9uX2lkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFlcnJvck9jKSB7XG4gICAgICAgICAgb2N1cGFjaW9uID0gb2NEYXRhXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBPY3VwYWNpw7NuIG9idGVuaWRhOicsIG9jdXBhY2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPYnRlbmVyIHByb2Zlc2nDs24gc2kgZXhpc3RlXG4gICAgICBsZXQgcHJvZmVzaW9uOiBQcm9mZXNpb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgIGlmICh1c3VhcmlvQmFzaWNvLnByb2Zlc2lvbl9pZCkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHByb2ZEYXRhLCBlcnJvcjogZXJyb3JQcm9mIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdwcm9mZXNpb25lcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmVxKCdpZCcsIHVzdWFyaW9CYXNpY28ucHJvZmVzaW9uX2lkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFlcnJvclByb2YpIHtcbiAgICAgICAgICBwcm9mZXNpb24gPSBwcm9mRGF0YVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUHJvZmVzacOzbiBvYnRlbmlkYTonLCBwcm9mZXNpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZW5lciByZWxhY2lvbmVzIGZhbWlsaWFyZXMgc2kgZXhpc3RlblxuICAgICAgbGV0IHJlbGFjaW9uZXNGYW1pbGlhcmVzOiB7XG4gICAgICAgIGlkOiBzdHJpbmdcbiAgICAgICAgdGlwb19yZWxhY2lvbjogRGF0YWJhc2VbXCJwdWJsaWNcIl1bXCJFbnVtc1wiXVtcImVudW1fdGlwb19yZWxhY2lvblwiXVxuICAgICAgICBlc19wcmluY2lwYWw6IGJvb2xlYW4gfCBudWxsXG4gICAgICAgIGZhbWlsaWFyOiBVc3VhcmlvXG4gICAgICAgIGVzX3VzdWFyaW8xOiBib29sZWFuIC8vIFBhcmEgZGVidWc6IGluZGljYSBzaSBlbCB1c3VhcmlvIGFjdHVhbCBlcyB1c3VhcmlvMSBlbiBlc3RhIHJlbGFjacOzblxuICAgICAgICB0aXBvX3JlbGFjaW9uX29yaWdpbmFsOiBEYXRhYmFzZVtcInB1YmxpY1wiXVtcIkVudW1zXCJdW1wiZW51bV90aXBvX3JlbGFjaW9uXCJdIC8vIFBhcmEgZGVidWc6IHRpcG8gb3JpZ2luYWwgZGUgbGEgQkRcbiAgICAgIH1bXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBCdXNjYW5kbyByZWxhY2lvbmVzIGZhbWlsaWFyZXMgcGFyYSB1c3VhcmlvOicsIGlkKVxuXG4gICAgICAvLyBCdXNjYXIgcmVsYWNpb25lcyBkb25kZSBlc3RlIHVzdWFyaW8gZXMgdXN1YXJpbzEgbyB1c3VhcmlvMlxuICAgICAgY29uc3QgeyBkYXRhOiByZWxhY2lvbmVzLCBlcnJvcjogZXJyb3JSZWxhY2lvbmVzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncmVsYWNpb25lc191c3VhcmlvcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCB0aXBvX3JlbGFjaW9uLCBlc19wcmluY2lwYWwsIHVzdWFyaW8xX2lkLCB1c3VhcmlvMl9pZCcpXG4gICAgICAgIC5vcihgdXN1YXJpbzFfaWQuZXEuJHtpZH0sdXN1YXJpbzJfaWQuZXEuJHtpZH1gKVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBDb25zdWx0YSBkZSByZWxhY2lvbmVzOicsIHsgcmVsYWNpb25lcywgZXJyb3JSZWxhY2lvbmVzIH0pXG5cbiAgICAgIGlmICghZXJyb3JSZWxhY2lvbmVzICYmIHJlbGFjaW9uZXMgJiYgcmVsYWNpb25lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUmVsYWNpb25lcyBlbmNvbnRyYWRhczonLCByZWxhY2lvbmVzKVxuICAgICAgICBcbiAgICAgICAgLy8gT2J0ZW5lciBsb3MgSURzIGRlIGxvcyB1c3VhcmlvcyByZWxhY2lvbmFkb3NcbiAgICAgICAgY29uc3QgaWRzUmVsYWNpb25hZG9zID0gcmVsYWNpb25lcy5tYXAociA9PiB7XG4gICAgICAgICAgY29uc3QgZXNVc3VhcmlvMSA9IHIudXN1YXJpbzFfaWQgPT09IGlkXG4gICAgICAgICAgY29uc3QgZmFtaWxpYXJJZCA9IGVzVXN1YXJpbzEgPyByLnVzdWFyaW8yX2lkIDogci51c3VhcmlvMV9pZFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFJlbGFjacOzbjogdXN1YXJpbzE9JHtyLnVzdWFyaW8xX2lkfSwgdXN1YXJpbzI9JHtyLnVzdWFyaW8yX2lkfSwgdGlwbz0ke3IudGlwb19yZWxhY2lvbn1gKVxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFVzdWFyaW8gYWN0dWFsOiAke2lkfSwgRmFtaWxpYXIgSUQ6ICR7ZmFtaWxpYXJJZH1gKVxuICAgICAgICAgIHJldHVybiBmYW1pbGlhcklkXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gSURzIGRlIHVzdWFyaW9zIHJlbGFjaW9uYWRvczonLCBpZHNSZWxhY2lvbmFkb3MpXG5cbiAgICAgICAgLy8gT2J0ZW5lciBpbmZvcm1hY2nDs24gZGUgbG9zIHVzdWFyaW9zIHJlbGFjaW9uYWRvc1xuICAgICAgICBjb25zdCB7IGRhdGE6IHVzdWFyaW9zRmFtaWxpYXJlcywgZXJyb3I6IGVycm9yVXN1YXJpb3NGYW1pbGlhcmVzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c3VhcmlvcycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmluKCdpZCcsIGlkc1JlbGFjaW9uYWRvcylcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBVc3VhcmlvcyBmYW1pbGlhcmVzIG9idGVuaWRvczonLCB7IHVzdWFyaW9zRmFtaWxpYXJlcywgZXJyb3JVc3Vhcmlvc0ZhbWlsaWFyZXMgfSlcblxuICAgICAgICBpZiAoIWVycm9yVXN1YXJpb3NGYW1pbGlhcmVzICYmIHVzdWFyaW9zRmFtaWxpYXJlcykge1xuICAgICAgICAgIHJlbGFjaW9uZXNGYW1pbGlhcmVzID0gcmVsYWNpb25lcy5tYXAociA9PiB7XG4gICAgICAgICAgICBjb25zdCBlc1VzdWFyaW8xID0gci51c3VhcmlvMV9pZCA9PT0gaWRcbiAgICAgICAgICAgIGNvbnN0IGZhbWlsaWFySWQgPSBlc1VzdWFyaW8xID8gci51c3VhcmlvMl9pZCA6IHIudXN1YXJpbzFfaWRcbiAgICAgICAgICAgIGNvbnN0IGZhbWlsaWFyID0gdXN1YXJpb3NGYW1pbGlhcmVzLmZpbmQodWYgPT4gdWYuaWQgPT09IGZhbWlsaWFySWQpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENvbnN0cnV5ZW5kbyByZWxhY2nDs246YCwge1xuICAgICAgICAgICAgICByZWxhY2lvbklkOiByLmlkLFxuICAgICAgICAgICAgICB0aXBvOiByLnRpcG9fcmVsYWNpb24sXG4gICAgICAgICAgICAgIGVzUHJpbmNpcGFsOiByLmVzX3ByaW5jaXBhbCxcbiAgICAgICAgICAgICAgZmFtaWxpYXJJZCxcbiAgICAgICAgICAgICAgZmFtaWxpYXJFbmNvbnRyYWRvOiAhIWZhbWlsaWFyLFxuICAgICAgICAgICAgICBmYW1pbGlhck5vbWJyZTogZmFtaWxpYXIgPyBgJHtmYW1pbGlhci5ub21icmV9ICR7ZmFtaWxpYXIuYXBlbGxpZG99YCA6ICdOTyBFTkNPTlRSQURPJyxcbiAgICAgICAgICAgICAgZXNVc3VhcmlvMSxcbiAgICAgICAgICAgICAgdXN1YXJpb0FjdHVhbDogaWQsXG4gICAgICAgICAgICAgIHVzdWFyaW8xOiByLnVzdWFyaW8xX2lkLFxuICAgICAgICAgICAgICB1c3VhcmlvMjogci51c3VhcmlvMl9pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW52ZXJ0aXIgbGEgcmVsYWNpw7NuIHNpIGVsIHVzdWFyaW8gYWN0dWFsIGVzIHVzdWFyaW8xX2lkXG4gICAgICAgICAgICBsZXQgdGlwb1JlbGFjaW9uTW9zdHJhZG86IGFueSA9IHIudGlwb19yZWxhY2lvblxuICAgICAgICAgICAgaWYgKGVzVXN1YXJpbzEpIHtcbiAgICAgICAgICAgICAgLy8gU29sbyBpbnZlcnRpciBzaSBsYSByZWxhY2nDs24gbm8gZXMgcmVjw61wcm9jYVxuICAgICAgICAgICAgICBpZiAoIWVzUmVsYWNpb25SZWNpcHJvY2Eoci50aXBvX3JlbGFjaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGFjaW9uSW52ZXJ0aWRhID0gaW52ZXJ0aXJSZWxhY2lvbihyLnRpcG9fcmVsYWNpb24pXG4gICAgICAgICAgICAgICAgaWYgKHJlbGFjaW9uSW52ZXJ0aWRhKSB7XG4gICAgICAgICAgICAgICAgICB0aXBvUmVsYWNpb25Nb3N0cmFkbyA9IHJlbGFjaW9uSW52ZXJ0aWRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiByLmlkLFxuICAgICAgICAgICAgICB0aXBvX3JlbGFjaW9uOiB0aXBvUmVsYWNpb25Nb3N0cmFkbyxcbiAgICAgICAgICAgICAgZXNfcHJpbmNpcGFsOiByLmVzX3ByaW5jaXBhbCxcbiAgICAgICAgICAgICAgZmFtaWxpYXI6IGZhbWlsaWFyISxcbiAgICAgICAgICAgICAgZXNfdXN1YXJpbzE6IGVzVXN1YXJpbzEsIC8vIFBhcmEgZGVidWdcbiAgICAgICAgICAgICAgdGlwb19yZWxhY2lvbl9vcmlnaW5hbDogci50aXBvX3JlbGFjaW9uIC8vIFBhcmEgZGVidWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maWx0ZXIociA9PiByLmZhbWlsaWFyKSAvLyBTb2xvIGluY2x1aXIgcmVsYWNpb25lcyBjb24gdXN1YXJpb3MgdsOhbGlkb3NcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgUmVsYWNpb25lcyBmYW1pbGlhcmVzIGNvbnN0cnVpZGFzOicsIHJlbGFjaW9uZXNGYW1pbGlhcmVzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIE5vIHNlIGVuY29udHJhcm9uIHJlbGFjaW9uZXMgZmFtaWxpYXJlcyBvIGh1Ym8gZXJyb3I6JywgZXJyb3JSZWxhY2lvbmVzKVxuICAgICAgfVxuXG4gICAgICAvLyBDb25zdHJ1aXIgZWwgb2JqZXRvIGNvbXBsZXRvIGRlbCB1c3VhcmlvXG4gICAgICBjb25zdCB1c3VhcmlvQ29tcGxldG86IFVzdWFyaW9EZXRhbGxhZG8gPSB7XG4gICAgICAgIC4uLnVzdWFyaW9CYXNpY28sXG4gICAgICAgIHVzdWFyaW9fcm9sZXM6IHJvbGVzQ29tcGxldG9zLFxuICAgICAgICBkaXJlY2Npb24sXG4gICAgICAgIGZhbWlsaWEsXG4gICAgICAgIG9jdXBhY2lvbixcbiAgICAgICAgcHJvZmVzaW9uLFxuICAgICAgICByZWxhY2lvbmVzX2ZhbWlsaWFyZXM6IHJlbGFjaW9uZXNGYW1pbGlhcmVzXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVXN1YXJpbyBjb21wbGV0byBjb25zdHJ1aWRvOicsIHVzdWFyaW9Db21wbGV0bylcbiAgICAgIHNldFVzdWFyaW8odXN1YXJpb0NvbXBsZXRvKVxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW5lc3BlcmFkbzonLCBlcnIpXG4gICAgICBzZXRFcnJvcignRXJyb3IgaW5lc3BlcmFkbyBhbCBjYXJnYXIgZGF0b3MnKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBjYXJnYXJVc3VhcmlvKClcbiAgICB9XG4gIH0sIFtpZF0pXG5cbiAgcmV0dXJuIHtcbiAgICB1c3VhcmlvLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgcmVjYXJnYXI6IGNhcmdhclVzdWFyaW9cbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY3JlYXRlQ2xpZW50IiwiaW52ZXJ0aXJSZWxhY2lvbiIsImVzUmVsYWNpb25SZWNpcHJvY2EiLCJ1c2VVc3VhcmlvRGV0YWxsZSIsImlkIiwidXN1YXJpbyIsInNldFVzdWFyaW8iLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJzdXBhYmFzZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImNhcmdhclVzdWFyaW8iLCJjb25zb2xlIiwibG9nIiwiZGF0YSIsInVzdWFyaW9CYXNpY28iLCJlcnJvclVzdWFyaW8iLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJtZXNzYWdlIiwidXN1YXJpb1JvbGVzIiwiZXJyb3JSb2xlcyIsInJvbGVzQ29tcGxldG9zIiwibGVuZ3RoIiwicm9sSWRzIiwibWFwIiwidXIiLCJyb2xfaWQiLCJyb2xlc1Npc3RlbWEiLCJlcnJvclJvbGVzU2lzdGVtYSIsImluIiwidXN1YXJpb19pZCIsInJvbGVzX3Npc3RlbWEiLCJmaW5kIiwicnMiLCJkaXJlY2Npb24iLCJ1bmRlZmluZWQiLCJkaXJlY2Npb25faWQiLCJkaXJEYXRhIiwiZXJyb3JEaXIiLCJmYW1pbGlhIiwiZmFtaWxpYV9pZCIsImZhbURhdGEiLCJlcnJvckZhbSIsIm9jdXBhY2lvbiIsIm9jdXBhY2lvbl9pZCIsIm9jRGF0YSIsImVycm9yT2MiLCJwcm9mZXNpb24iLCJwcm9mZXNpb25faWQiLCJwcm9mRGF0YSIsImVycm9yUHJvZiIsInJlbGFjaW9uZXNGYW1pbGlhcmVzIiwicmVsYWNpb25lcyIsImVycm9yUmVsYWNpb25lcyIsIm9yIiwiaWRzUmVsYWNpb25hZG9zIiwiciIsImVzVXN1YXJpbzEiLCJ1c3VhcmlvMV9pZCIsImZhbWlsaWFySWQiLCJ1c3VhcmlvMl9pZCIsInRpcG9fcmVsYWNpb24iLCJ1c3Vhcmlvc0ZhbWlsaWFyZXMiLCJlcnJvclVzdWFyaW9zRmFtaWxpYXJlcyIsImZhbWlsaWFyIiwidWYiLCJyZWxhY2lvbklkIiwidGlwbyIsImVzUHJpbmNpcGFsIiwiZXNfcHJpbmNpcGFsIiwiZmFtaWxpYXJFbmNvbnRyYWRvIiwiZmFtaWxpYXJOb21icmUiLCJub21icmUiLCJhcGVsbGlkbyIsInVzdWFyaW9BY3R1YWwiLCJ1c3VhcmlvMSIsInVzdWFyaW8yIiwidGlwb1JlbGFjaW9uTW9zdHJhZG8iLCJyZWxhY2lvbkludmVydGlkYSIsImVzX3VzdWFyaW8xIiwidGlwb19yZWxhY2lvbl9vcmlnaW5hbCIsImZpbHRlciIsInVzdWFyaW9Db21wbGV0byIsInVzdWFyaW9fcm9sZXMiLCJyZWxhY2lvbmVzX2ZhbWlsaWFyZXMiLCJlcnIiLCJyZWNhcmdhciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-usuario-detalle.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/config/relaciones-familiares.ts":
/*!*********************************************!*\
  !*** ./lib/config/relaciones-familiares.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELACIONES_FAMILIARES: () => (/* binding */ RELACIONES_FAMILIARES),\n/* harmony export */   esRelacionReciproca: () => (/* binding */ esRelacionReciproca),\n/* harmony export */   invertirRelacion: () => (/* binding */ invertirRelacion),\n/* harmony export */   obtenerColorRelacion: () => (/* binding */ obtenerColorRelacion),\n/* harmony export */   obtenerNombreRelacion: () => (/* binding */ obtenerNombreRelacion)\n/* harmony export */ });\n// Configuraci√≥n para relaciones familiares\nconst RELACIONES_FAMILIARES = {\n    // Relaciones que requieren inversi√≥n cuando el usuario actual es usuario1_id\n    RELACIONES_INVERTIBLES: {\n        'padre': 'hijo',\n        'hijo': 'padre',\n        'tutor': 'tutelado'\n    },\n    // Relaciones que son rec√≠procas (no se invierten)\n    RELACIONES_RECIPROCAS: [\n        'conyuge',\n        'hermano',\n        'otro_familiar'\n    ],\n    // Nombres en espa√±ol para cada tipo de relaci√≥n\n    NOMBRES_ESPA√ëOL: {\n        'conyuge': 'C√≥nyuge',\n        'padre': 'Padre',\n        'hijo': 'Hijo/a',\n        'hermano': 'Hermano/a',\n        'tutor': 'Tutor',\n        'tutelado': 'Tutelado/a',\n        'otro_familiar': 'Otro Familiar'\n    },\n    // Colores para cada tipo de relaci√≥n\n    COLORS: {\n        'conyuge': 'from-pink-500 to-pink-600',\n        'padre': 'from-blue-500 to-blue-600',\n        'hijo': 'from-green-500 to-green-600',\n        'hermano': 'from-indigo-500 to-indigo-600',\n        'tutor': 'from-purple-500 to-purple-600',\n        'tutelado': 'from-purple-400 to-purple-500',\n        'otro_familiar': 'from-gray-500 to-gray-600'\n    }\n};\n// Funci√≥n para obtener el nombre en espa√±ol de una relaci√≥n\nfunction obtenerNombreRelacion(tipoRelacion, familiar) {\n    // Si tenemos informaci√≥n del familiar, usar g√©nero espec√≠fico\n    if (familiar && familiar.genero) {\n        switch(tipoRelacion){\n            case 'padre':\n                return familiar.genero === 'Femenino' ? 'Madre' : 'Padre';\n            case 'hijo':\n                return familiar.genero === 'Femenino' ? 'Hija' : 'Hijo';\n            case 'hermano':\n                return familiar.genero === 'Femenino' ? 'Hermana' : 'Hermano';\n            case 'tutor':\n                return familiar.genero === 'Femenino' ? 'Tutora' : 'Tutor';\n            case 'tutelado':\n                return familiar.genero === 'Femenino' ? 'Tutelada' : 'Tutelado';\n        }\n    }\n    // Si no hay g√©nero o es otro tipo, usar nombres gen√©ricos\n    return RELACIONES_FAMILIARES.NOMBRES_ESPA√ëOL[tipoRelacion] || tipoRelacion.charAt(0).toUpperCase() + tipoRelacion.slice(1);\n}\n// Funci√≥n para obtener el color de una relaci√≥n\nfunction obtenerColorRelacion(tipoRelacion) {\n    return RELACIONES_FAMILIARES.COLORS[tipoRelacion] || 'from-orange-500 to-orange-600';\n}\n// Funci√≥n para invertir una relaci√≥n\nfunction invertirRelacion(tipoRelacion) {\n    return RELACIONES_FAMILIARES.RELACIONES_INVERTIBLES[tipoRelacion] || null;\n}\n// Funci√≥n para verificar si una relaci√≥n es rec√≠proca\nfunction esRelacionReciproca(tipoRelacion) {\n    return RELACIONES_FAMILIARES.RELACIONES_RECIPROCAS.includes(tipoRelacion);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb25maWcvcmVsYWNpb25lcy1mYW1pbGlhcmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBQ3BDLE1BQU1BLHdCQUF3QjtJQUNuQyw2RUFBNkU7SUFDN0VDLHdCQUF3QjtRQUN0QixTQUFTO1FBQ1QsUUFBUTtRQUNSLFNBQVM7SUFFWDtJQUVBLGtEQUFrRDtJQUNsREMsdUJBQXVCO1FBQUM7UUFBVztRQUFXO0tBQWdCO0lBRTlELGdEQUFnRDtJQUNoREMsaUJBQWlCO1FBQ2YsV0FBVztRQUNYLFNBQVM7UUFDVCxRQUFRO1FBQ1IsV0FBVztRQUNYLFNBQVM7UUFDVCxZQUFZO1FBQ1osaUJBQWlCO0lBQ25CO0lBRUEscUNBQXFDO0lBQ3JDQyxRQUFRO1FBQ04sV0FBVztRQUNYLFNBQVM7UUFDVCxRQUFRO1FBQ1IsV0FBVztRQUNYLFNBQVM7UUFDVCxZQUFZO1FBQ1osaUJBQWlCO0lBQ25CO0FBQ0YsRUFBVTtBQUVWLDREQUE0RDtBQUNyRCxTQUFTQyxzQkFBc0JDLFlBQW9CLEVBQUVDLFFBQWM7SUFDeEUsOERBQThEO0lBQzlELElBQUlBLFlBQVlBLFNBQVNDLE1BQU0sRUFBRTtRQUMvQixPQUFRRjtZQUNOLEtBQUs7Z0JBQ0gsT0FBT0MsU0FBU0MsTUFBTSxLQUFLLGFBQWEsVUFBVTtZQUNwRCxLQUFLO2dCQUNILE9BQU9ELFNBQVNDLE1BQU0sS0FBSyxhQUFhLFNBQVM7WUFDbkQsS0FBSztnQkFDSCxPQUFPRCxTQUFTQyxNQUFNLEtBQUssYUFBYSxZQUFZO1lBQ3RELEtBQUs7Z0JBQ0gsT0FBT0QsU0FBU0MsTUFBTSxLQUFLLGFBQWEsV0FBVztZQUNyRCxLQUFLO2dCQUNILE9BQU9ELFNBQVNDLE1BQU0sS0FBSyxhQUFhLGFBQWE7UUFDekQ7SUFDRjtJQUVBLDBEQUEwRDtJQUMxRCxPQUFPUixzQkFBc0JHLGVBQWUsQ0FBQ0csYUFBbUUsSUFDekdBLGFBQWFHLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtKLGFBQWFLLEtBQUssQ0FBQztBQUNuRTtBQUVBLGdEQUFnRDtBQUN6QyxTQUFTQyxxQkFBcUJOLFlBQW9CO0lBQ3ZELE9BQU9OLHNCQUFzQkksTUFBTSxDQUFDRSxhQUEwRCxJQUN2RjtBQUNUO0FBRUEscUNBQXFDO0FBQzlCLFNBQVNPLGlCQUFpQlAsWUFBb0I7SUFDbkQsT0FBT04sc0JBQXNCQyxzQkFBc0IsQ0FBQ0ssYUFBMEUsSUFBSTtBQUNwSTtBQUVBLHNEQUFzRDtBQUMvQyxTQUFTUSxvQkFBb0JSLFlBQW9CO0lBQ3RELE9BQU9OLHNCQUFzQkUscUJBQXFCLENBQUNhLFFBQVEsQ0FBQ1Q7QUFDOUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pc2FhY3BhZXp6L0dsb2JhbCBDb25uZWN0L2xpYi9jb25maWcvcmVsYWNpb25lcy1mYW1pbGlhcmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbmZpZ3VyYWNpw7NuIHBhcmEgcmVsYWNpb25lcyBmYW1pbGlhcmVzXG5leHBvcnQgY29uc3QgUkVMQUNJT05FU19GQU1JTElBUkVTID0ge1xuICAvLyBSZWxhY2lvbmVzIHF1ZSByZXF1aWVyZW4gaW52ZXJzacOzbiBjdWFuZG8gZWwgdXN1YXJpbyBhY3R1YWwgZXMgdXN1YXJpbzFfaWRcbiAgUkVMQUNJT05FU19JTlZFUlRJQkxFUzoge1xuICAgICdwYWRyZSc6ICdoaWpvJyxcbiAgICAnaGlqbyc6ICdwYWRyZScsXG4gICAgJ3R1dG9yJzogJ3R1dGVsYWRvJyxcbiAgICAvLyAnaGVybWFubyc6ICdoZXJtYW5vJywgLy8gTG9zIGhlcm1hbm9zIHNvbiByZWPDrXByb2NvcyAobm8gc2UgaW52aWVydGVuKVxuICB9LFxuICBcbiAgLy8gUmVsYWNpb25lcyBxdWUgc29uIHJlY8OtcHJvY2FzIChubyBzZSBpbnZpZXJ0ZW4pXG4gIFJFTEFDSU9ORVNfUkVDSVBST0NBUzogWydjb255dWdlJywgJ2hlcm1hbm8nLCAnb3Ryb19mYW1pbGlhciddLFxuICBcbiAgLy8gTm9tYnJlcyBlbiBlc3Bhw7FvbCBwYXJhIGNhZGEgdGlwbyBkZSByZWxhY2nDs25cbiAgTk9NQlJFU19FU1BBw5FPTDoge1xuICAgICdjb255dWdlJzogJ0PDs255dWdlJyxcbiAgICAncGFkcmUnOiAnUGFkcmUnLFxuICAgICdoaWpvJzogJ0hpam8vYScsXG4gICAgJ2hlcm1hbm8nOiAnSGVybWFuby9hJyxcbiAgICAndHV0b3InOiAnVHV0b3InLFxuICAgICd0dXRlbGFkbyc6ICdUdXRlbGFkby9hJyxcbiAgICAnb3Ryb19mYW1pbGlhcic6ICdPdHJvIEZhbWlsaWFyJyxcbiAgfSxcbiAgXG4gIC8vIENvbG9yZXMgcGFyYSBjYWRhIHRpcG8gZGUgcmVsYWNpw7NuXG4gIENPTE9SUzoge1xuICAgICdjb255dWdlJzogJ2Zyb20tcGluay01MDAgdG8tcGluay02MDAnLFxuICAgICdwYWRyZSc6ICdmcm9tLWJsdWUtNTAwIHRvLWJsdWUtNjAwJyxcbiAgICAnaGlqbyc6ICdmcm9tLWdyZWVuLTUwMCB0by1ncmVlbi02MDAnLFxuICAgICdoZXJtYW5vJzogJ2Zyb20taW5kaWdvLTUwMCB0by1pbmRpZ28tNjAwJyxcbiAgICAndHV0b3InOiAnZnJvbS1wdXJwbGUtNTAwIHRvLXB1cnBsZS02MDAnLFxuICAgICd0dXRlbGFkbyc6ICdmcm9tLXB1cnBsZS00MDAgdG8tcHVycGxlLTUwMCcsXG4gICAgJ290cm9fZmFtaWxpYXInOiAnZnJvbS1ncmF5LTUwMCB0by1ncmF5LTYwMCcsXG4gIH1cbn0gYXMgY29uc3RcblxuLy8gRnVuY2nDs24gcGFyYSBvYnRlbmVyIGVsIG5vbWJyZSBlbiBlc3Bhw7FvbCBkZSB1bmEgcmVsYWNpw7NuXG5leHBvcnQgZnVuY3Rpb24gb2J0ZW5lck5vbWJyZVJlbGFjaW9uKHRpcG9SZWxhY2lvbjogc3RyaW5nLCBmYW1pbGlhcj86IGFueSk6IHN0cmluZyB7XG4gIC8vIFNpIHRlbmVtb3MgaW5mb3JtYWNpw7NuIGRlbCBmYW1pbGlhciwgdXNhciBnw6luZXJvIGVzcGVjw61maWNvXG4gIGlmIChmYW1pbGlhciAmJiBmYW1pbGlhci5nZW5lcm8pIHtcbiAgICBzd2l0Y2ggKHRpcG9SZWxhY2lvbikge1xuICAgICAgY2FzZSAncGFkcmUnOlxuICAgICAgICByZXR1cm4gZmFtaWxpYXIuZ2VuZXJvID09PSAnRmVtZW5pbm8nID8gJ01hZHJlJyA6ICdQYWRyZSdcbiAgICAgIGNhc2UgJ2hpam8nOlxuICAgICAgICByZXR1cm4gZmFtaWxpYXIuZ2VuZXJvID09PSAnRmVtZW5pbm8nID8gJ0hpamEnIDogJ0hpam8nXG4gICAgICBjYXNlICdoZXJtYW5vJzpcbiAgICAgICAgcmV0dXJuIGZhbWlsaWFyLmdlbmVybyA9PT0gJ0ZlbWVuaW5vJyA/ICdIZXJtYW5hJyA6ICdIZXJtYW5vJ1xuICAgICAgY2FzZSAndHV0b3InOlxuICAgICAgICByZXR1cm4gZmFtaWxpYXIuZ2VuZXJvID09PSAnRmVtZW5pbm8nID8gJ1R1dG9yYScgOiAnVHV0b3InXG4gICAgICBjYXNlICd0dXRlbGFkbyc6XG4gICAgICAgIHJldHVybiBmYW1pbGlhci5nZW5lcm8gPT09ICdGZW1lbmlubycgPyAnVHV0ZWxhZGEnIDogJ1R1dGVsYWRvJ1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU2kgbm8gaGF5IGfDqW5lcm8gbyBlcyBvdHJvIHRpcG8sIHVzYXIgbm9tYnJlcyBnZW7DqXJpY29zXG4gIHJldHVybiBSRUxBQ0lPTkVTX0ZBTUlMSUFSRVMuTk9NQlJFU19FU1BBw5FPTFt0aXBvUmVsYWNpb24gYXMga2V5b2YgdHlwZW9mIFJFTEFDSU9ORVNfRkFNSUxJQVJFUy5OT01CUkVTX0VTUEHDkU9MXSB8fCBcbiAgICAgICAgIHRpcG9SZWxhY2lvbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRpcG9SZWxhY2lvbi5zbGljZSgxKVxufVxuXG4vLyBGdW5jacOzbiBwYXJhIG9idGVuZXIgZWwgY29sb3IgZGUgdW5hIHJlbGFjacOzblxuZXhwb3J0IGZ1bmN0aW9uIG9idGVuZXJDb2xvclJlbGFjaW9uKHRpcG9SZWxhY2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIFJFTEFDSU9ORVNfRkFNSUxJQVJFUy5DT0xPUlNbdGlwb1JlbGFjaW9uIGFzIGtleW9mIHR5cGVvZiBSRUxBQ0lPTkVTX0ZBTUlMSUFSRVMuQ09MT1JTXSB8fCBcbiAgICAgICAgICdmcm9tLW9yYW5nZS01MDAgdG8tb3JhbmdlLTYwMCdcbn1cblxuLy8gRnVuY2nDs24gcGFyYSBpbnZlcnRpciB1bmEgcmVsYWNpw7NuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0aXJSZWxhY2lvbih0aXBvUmVsYWNpb246IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gUkVMQUNJT05FU19GQU1JTElBUkVTLlJFTEFDSU9ORVNfSU5WRVJUSUJMRVNbdGlwb1JlbGFjaW9uIGFzIGtleW9mIHR5cGVvZiBSRUxBQ0lPTkVTX0ZBTUlMSUFSRVMuUkVMQUNJT05FU19JTlZFUlRJQkxFU10gfHwgbnVsbFxufVxuXG4vLyBGdW5jacOzbiBwYXJhIHZlcmlmaWNhciBzaSB1bmEgcmVsYWNpw7NuIGVzIHJlY8OtcHJvY2FcbmV4cG9ydCBmdW5jdGlvbiBlc1JlbGFjaW9uUmVjaXByb2NhKHRpcG9SZWxhY2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBSRUxBQ0lPTkVTX0ZBTUlMSUFSRVMuUkVMQUNJT05FU19SRUNJUFJPQ0FTLmluY2x1ZGVzKHRpcG9SZWxhY2lvbiBhcyBhbnkpXG59XG4iXSwibmFtZXMiOlsiUkVMQUNJT05FU19GQU1JTElBUkVTIiwiUkVMQUNJT05FU19JTlZFUlRJQkxFUyIsIlJFTEFDSU9ORVNfUkVDSVBST0NBUyIsIk5PTUJSRVNfRVNQQcORT0wiLCJDT0xPUlMiLCJvYnRlbmVyTm9tYnJlUmVsYWNpb24iLCJ0aXBvUmVsYWNpb24iLCJmYW1pbGlhciIsImdlbmVybyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJvYnRlbmVyQ29sb3JSZWxhY2lvbiIsImludmVydGlyUmVsYWNpb24iLCJlc1JlbGFjaW9uUmVjaXByb2NhIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/config/relaciones-familiares.ts\n"));

/***/ })

});